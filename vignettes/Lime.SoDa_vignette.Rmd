---
title: "Lime.SoDa Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Lime.SoDa_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
Precision Liming Soil Datasets (Lime.SoDa) is a collection of datasets in the context of field- and farm-scale soil mapping. In the following we will provide a guideline on how to use `Lime.SoDa`.



### Lime.SoDa structure
Installing `Lime.SoDa` from GitHub by: 

```{r setup}
#remotes::install_github("JonasSchmidinger/Lime.SoDa")

library(Lime.SoDa)
library(sf)
```

`Lime.SoDa` consists of seven tabular datasets that are ready-to-go for modelling purposes:

```{r}
data(package = "Lime.SoDa")$results[,3] # List datasets from Lime.SoDa
```

The dataset-codes are named after the geographic region and the sample size, e.g. `BB.250` is a dataset from Brandenburg (BB) with 250 reference soil samples. Further information about the methodology, sampling, feature codes etc. can be found in the metadata of each dataset:

```{r}
?BB.250 #Access metadata
```

Datasets are stored as a list. This list contains the tabular dataset (`$Dataset`), pre-defined folds (`$Folds`) for a 10-fold cross-validation and coordinates (`$Coordinates`):

```{r}
head(BB.250$Dataset)

BB.250$Folds

head(BB.250$Coordinates)
```

Each dataset has SOM or SOC, pH and Clay as target soil properties, which are stored in the first three columns of the `$Dataset`. They can be recognized by their suffix `_target` e.g., `Clay_target`:

```{r}
str(BB.250$Dataset[1:3]) 
```

Features are dataset specific. Features were generated by various proximal soil sensors, remote sensing derived spectral data and terrain parameters:

```{r}
colnames(BB.250$Dataset[-c(1:3)])
colnames(BB.30$Dataset[-c(1:3)])
colnames(BB.72$Dataset[-c(1:3)])
```

Spatial coordinates are available for most but not all datasets. For some datasets (e.g., `SSP.58`) it could not be provided, usually because of privacy reasons. For example, for `BB.250` coordinates were included, but for `SSP.58` they were excluded and `$Coordinates` was filled with an `NA` value:

```{r}
#When Coordinates are included:
head(BB.250$Coordinates)

#When Coordinates are excluded:
head(SSP.58$Coordinates)
```

Coordinates are ordered according to the tabular dataset. Therefore, coordinates can be merged with the dataset through a simple `cbind()`:

```{r}
BB.250_dataset.with.coordinates <- cbind(BB.250$Coordinates,BB.250$Dataset) # Merge coordinates with dataset

BB.250_dataset.with.coordinates.sf <- st_as_sf(x = BB.250_dataset.with.coordinates, 
                         coords = c("x_25833", "y_25833")) # Make it spatial
st_crs(BB.250_dataset.with.coordinates.sf) <- 25833 

plot(BB.250_dataset.with.coordinates.sf[c(1:3)])
```

### Modelling with Lime.SoDa

To ensure comparability between different studies that implemented Lime.SoDa, the pre-defined folds should be used for modelling: 

```{r}
table(BB.250$Folds) # Folds are defined through a vector with numbers from 1 - 10

# Splitting the dataset into training and testing folds for the example of the first fold
training_data_BB.250 <- BB.250$Dataset[BB.250$Folds != 1,] 
testing_data_BB.250 <- BB.250$Dataset[BB.250$Folds == 1,]
```

In the following simple example, the performance of a multiple linear regression for `BB.250` is evaluated for SOC by looping over the folds (i.e. 10-fold cross validation):


```{r}
BB.250_dataset_predict.SOC <- BB.250$Dataset[-c(2:3)] # In this example, only SOC is predicted. Hence, Clay_target and pH_target are excluded

predicted_values <- c() # To store predicted values in this vector
testing_values <- c() # To store testing fold values in this vector

for (i in 1:10){
  training_data <- BB.250_dataset_predict.SOC[BB.250$Folds != i,] # Exclude testing fold from training data
  testing_data <- BB.250_dataset_predict.SOC[BB.250$Folds == i,] # Define testing fold as testing data
  
  MLR_model <- lm("SOC_target~.", data = training_data) # Fit MLR to predict SOC
  MLR_model_predictions <- predict(MLR_model, testing_data) # Predict values of testing fold
  
  predicted_values <- c(predicted_values, MLR_model_predictions) # Store predicted values for testing fold
  testing_values <- c(testing_values, testing_data$SOC_target) # Store real observed values from testing fold
}

# R-squared
1 - sum((predicted_values - testing_values)^2) / sum((testing_values - mean(testing_values))^2)
# RMSE
sqrt(mean((predicted_values - testing_values)^2))
```

As can be seen in this simple example, an R-squared of 0.76 and RMSE of 0.24 has been achieved. Based on the same folds, it can now be demonstrated how other methods perform on the same dataset compared to MLR. This allows comparability, i.e., results can be compared without the need to repeat the analysis twice.

### How to cite Lime.SoDa

```{r}
citation("Lime.SoDa")
```

We refer to the associated paper for more information on Lime.SoDa and its application in soil mapping.

