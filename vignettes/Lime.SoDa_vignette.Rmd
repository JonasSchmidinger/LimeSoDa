---
title: "Lime.SoDa Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Lime.SoDa_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
Precision Liming Soil Datasets (Lime.SoDa) is a collection of datasets for the context of field- and farm-scale soil mapping. In the following we will provide information on how to use `Lime.SoDa`.



### Lime.SoDa structure
Setup `Lime.SoDa` for R-environment by downloading it from GitHub. 

```{r setup}
#Insert downloadable link to my github page later 

library(Lime.SoDa)
library(sf)
```

`Lime.SoDa` consists of seven tabular datasets that are ready-to-go for modelling purposes.

```{r}
data(package = "Lime.SoDa")$results[,3] # List datasets from Lime.SoDa
```

The dataset-codes are named after the geographic region and the sample size, e.g. `BB.250` is a dataset from Brandenburg (BB) with 250 reference soil samples.

Datasets can be accessed through a list, which contains the tabular dataset (`$Dataset`), pre-defined folds (`$Folds`) for a 10-fold cross-validation and coordinates (`$Coordinates`).

```{r}
head(BB.250$Dataset)

BB.250$Folds

head(BB.250$Coordinates)
```

Further information about the methodology, sampling, feature codes etc. can be found in the metadata of each dataset.

```{r}
?BB.250 #Access metadata
```

Each dataset has SOM/SOC, pH and Clay as target soil properties, which are in all datasets the first three columns and suffix `_target` e.g., `Clay_target`.

```{r}
str(BB.250$Dataset[1:3]) 
```

Features are dataset specific and range from various proximal soil sensors, remote sensing derived spectral data and terrain attributes. 

```{r}
colnames(BB.250$Dataset[-c(1:3)])
colnames(BB.30$Dataset[-c(1:3)])
colnames(BB.72$Dataset[-c(1:3)])
```

Spatial coordinates are available for most but not all datasets, mostly because of privacy reasons. E.g., for `BB.250` coordinates were included, but for `SSP.58` it was excluded and filled with `NA` values.

```{r}
#When Coordinates are included:
head(BB.250$Coordinates)

#When Coordinates are excluded:
head(SSP.58$Coordinates)
```

Coordinates can be merged with the dataset through a simple `cbind()`.

```{r}
BB.250_dataset.with.coordinates <- cbind(BB.250$Coordinates,BB.250$Dataset) # Merge coordinates with dataset

BB.250_dataset.with.coordinates.sf <- st_as_sf(x = BB.250_dataset.with.coordinates, 
                         coords = c("x_25833", "y_25833")) # Make it spatial
st_crs(BB.250_dataset.with.coordinates.sf) <- 25833 

plot(BB.250_dataset.with.coordinates.sf[c(1:3)])
```

### Modelling with Lime.SoDa

To ensure comparability between different studies that implemented Lime.SoDa, the pre-defined folds should be used for modelling. 

```{r}
table(BB.250$Folds) # Folds are defined through a vector with numbers from 1 - 10

# How to split the dataset into training and testing folds for the example of the first fold
training_data_BB.250 <- BB.250$Dataset[BB.250$Folds != 1,] 
testing_data_BB.250 <- BB.250$Dataset[BB.250$Folds == 1,]
```

In the following simple example, the performance of a multiple linear regression for `BB.250` is evaluated for SOC by looping over the folds (i.e. 10-fold cross validation).


```{r}
BB.250_dataset_predict.SOC <- BB.250$Dataset[-c(2:3)] # In this example, only SOC is predicted. Hence, Clay_target and pH_target

predicted_values <- c() # Store predicted values in this vector
testing_values <- c() # Store testinging fold values in this vector

for (i in 1:10){
  training_data <- BB.250_dataset_predict.SOC[BB.250$Folds != i,] # Exclude testing fold from training data
  testing_data <- BB.250_dataset_predict.SOC[BB.250$Folds == i,] # Define testing fold as testing data
  
  MLR_model <- lm("SOM_target ~ .", data = training_data) # Fit MLR to predict SOC
  MLR_model_predictions <- predict(MLR_model, testing_data) # Predict values of testing fold
  
  predicted_values <- c(predicted_values, MLR_model_predictions) # Store predicted values for testing fold
  testing_values <- c(testing_values, testing_data$SOM_target) # Store real observed values from testing fold
}

# R-squared
1 - sum((predicted_values - testing_values)^2) / sum((testing_values - mean(testing_values))^2)
# RMSE
sqrt(mean((predicted_values - testing_values)^2))
```

As can be seen in this simple example, an R-squared of 0.76 and RMSE of 0.24 has been achieved. Based on the same folds, it can now be shown how other methods perform on the same dataset compared to the presented modelling-pipeline, ensuring comparability of results across different studies.


Further information can be found in the associated paper Schmidinger et al. (2024).

### Literature
*Schmidinger et al. (2024) to be added later*
